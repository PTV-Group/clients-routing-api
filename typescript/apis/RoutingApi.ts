/* tslint:disable */
/* eslint-disable */
/**
 * Routing
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers\' working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.32
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Driver,
  EmissionOptions,
  ErrorResponse,
  EtaResponse,
  EvOptions,
  MonetaryCostOptions,
  Options,
  PositionAtWaypoint,
  PositionOnRoute,
  Results,
  RouteRequest,
  RouteResponse,
  Vehicle,
  WorkLogbook,
} from '../models/index';
import {
    DriverFromJSON,
    DriverToJSON,
    EmissionOptionsFromJSON,
    EmissionOptionsToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    EtaResponseFromJSON,
    EtaResponseToJSON,
    EvOptionsFromJSON,
    EvOptionsToJSON,
    MonetaryCostOptionsFromJSON,
    MonetaryCostOptionsToJSON,
    OptionsFromJSON,
    OptionsToJSON,
    PositionAtWaypointFromJSON,
    PositionAtWaypointToJSON,
    PositionOnRouteFromJSON,
    PositionOnRouteToJSON,
    ResultsFromJSON,
    ResultsToJSON,
    RouteRequestFromJSON,
    RouteRequestToJSON,
    RouteResponseFromJSON,
    RouteResponseToJSON,
    VehicleFromJSON,
    VehicleToJSON,
    WorkLogbookFromJSON,
    WorkLogbookToJSON,
} from '../models/index';

export interface CalculateRouteRequest {
    waypoints?: Array<string>;
    routeId?: string;
    profile?: string;
    vehicle?: Vehicle;
    options?: Options;
    emissionOptions?: EmissionOptions;
    monetaryCostOptions?: MonetaryCostOptions;
    results?: Array<Results>;
}

export interface CalculateRoutePostRequest {
    routeRequest: RouteRequest;
    profile?: string;
    vehicle?: Vehicle;
    driver?: Driver;
    options?: Options;
    emissionOptions?: EmissionOptions;
    monetaryCostOptions?: MonetaryCostOptions;
    evOptions?: EvOptions;
    results?: Array<Results>;
}

export interface GetEstimatedTimeOfArrivalRequest {
    routeId: string;
    waypoint?: PositionAtWaypoint;
    position?: PositionOnRoute;
    time?: Date;
    workLogbook?: WorkLogbook;
}

export interface GetRouteByRouteIdRequest {
    routeId: string;
}

/**
 * 
 */
export class RoutingApi extends runtime.BaseAPI {

    /**
     * Calculates a route by specifying a list of waypoints.
     */
    async calculateRouteRaw(requestParameters: CalculateRouteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteResponse>> {
        const queryParameters: any = {};

        if (requestParameters['waypoints'] != null) {
            queryParameters['waypoints'] = requestParameters['waypoints'];
        }

        if (requestParameters['routeId'] != null) {
            queryParameters['routeId'] = requestParameters['routeId'];
        }

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['vehicle'] != null) {
            queryParameters['vehicle'] = requestParameters['vehicle'];
        }

        if (requestParameters['options'] != null) {
            queryParameters['options'] = requestParameters['options'];
        }

        if (requestParameters['emissionOptions'] != null) {
            queryParameters['emissionOptions'] = requestParameters['emissionOptions'];
        }

        if (requestParameters['monetaryCostOptions'] != null) {
            queryParameters['monetaryCostOptions'] = requestParameters['monetaryCostOptions'];
        }

        if (requestParameters['results'] != null) {
            queryParameters['results'] = requestParameters['results']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/routes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteResponseFromJSON(jsonValue));
    }

    /**
     * Calculates a route by specifying a list of waypoints.
     */
    async calculateRoute(requestParameters: CalculateRouteRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteResponse> {
        const response = await this.calculateRouteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
     */
    async calculateRoutePostRaw(requestParameters: CalculateRoutePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteResponse>> {
        if (requestParameters['routeRequest'] == null) {
            throw new runtime.RequiredError(
                'routeRequest',
                'Required parameter "routeRequest" was null or undefined when calling calculateRoutePost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['vehicle'] != null) {
            queryParameters['vehicle'] = requestParameters['vehicle'];
        }

        if (requestParameters['driver'] != null) {
            queryParameters['driver'] = requestParameters['driver'];
        }

        if (requestParameters['options'] != null) {
            queryParameters['options'] = requestParameters['options'];
        }

        if (requestParameters['emissionOptions'] != null) {
            queryParameters['emissionOptions'] = requestParameters['emissionOptions'];
        }

        if (requestParameters['monetaryCostOptions'] != null) {
            queryParameters['monetaryCostOptions'] = requestParameters['monetaryCostOptions'];
        }

        if (requestParameters['evOptions'] != null) {
            queryParameters['evOptions'] = requestParameters['evOptions'];
        }

        if (requestParameters['results'] != null) {
            queryParameters['results'] = requestParameters['results']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/routes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RouteRequestToJSON(requestParameters['routeRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteResponseFromJSON(jsonValue));
    }

    /**
     * Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
     */
    async calculateRoutePost(requestParameters: CalculateRoutePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteResponse> {
        const response = await this.calculateRoutePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
     */
    async getEstimatedTimeOfArrivalRaw(requestParameters: GetEstimatedTimeOfArrivalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EtaResponse>> {
        if (requestParameters['routeId'] == null) {
            throw new runtime.RequiredError(
                'routeId',
                'Required parameter "routeId" was null or undefined when calling getEstimatedTimeOfArrival().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['waypoint'] != null) {
            queryParameters['waypoint'] = requestParameters['waypoint'];
        }

        if (requestParameters['position'] != null) {
            queryParameters['position'] = requestParameters['position'];
        }

        if (requestParameters['time'] != null) {
            queryParameters['time'] = (requestParameters['time'] as any).toISOString();
        }

        if (requestParameters['workLogbook'] != null) {
            queryParameters['workLogbook'] = requestParameters['workLogbook'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/eta/{routeId}`.replace(`{${"routeId"}}`, encodeURIComponent(String(requestParameters['routeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EtaResponseFromJSON(jsonValue));
    }

    /**
     * Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
     */
    async getEstimatedTimeOfArrival(requestParameters: GetEstimatedTimeOfArrivalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EtaResponse> {
        const response = await this.getEstimatedTimeOfArrivalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
     */
    async getRouteByRouteIdRaw(requestParameters: GetRouteByRouteIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteResponse>> {
        if (requestParameters['routeId'] == null) {
            throw new runtime.RequiredError(
                'routeId',
                'Required parameter "routeId" was null or undefined when calling getRouteByRouteId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/routes/{routeId}`.replace(`{${"routeId"}}`, encodeURIComponent(String(requestParameters['routeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteResponseFromJSON(jsonValue));
    }

    /**
     * Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
     */
    async getRouteByRouteId(requestParameters: GetRouteByRouteIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteResponse> {
        const response = await this.getRouteByRouteIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
