/* tslint:disable */
/* eslint-disable */
/**
 * Routing
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver\'s working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.16
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { AvoidFeature } from './AvoidFeature';
import {
    AvoidFeatureFromJSON,
    AvoidFeatureFromJSONTyped,
    AvoidFeatureToJSON,
} from './AvoidFeature';
import type { PolylineFormat } from './PolylineFormat';
import {
    PolylineFormatFromJSON,
    PolylineFormatFromJSONTyped,
    PolylineFormatToJSON,
} from './PolylineFormat';
import type { RoutingMode } from './RoutingMode';
import {
    RoutingModeFromJSON,
    RoutingModeFromJSONTyped,
    RoutingModeToJSON,
} from './RoutingMode';
import type { TrafficMode } from './TrafficMode';
import {
    TrafficModeFromJSON,
    TrafficModeFromJSONTyped,
    TrafficModeToJSON,
} from './TrafficMode';

/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
     * This field is mutually exclusive with **arrivalTime**.
     * If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_.
     * If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint.
     * Responses will contain the offset to UTC specified in the request or that of the start waypoint.
     * The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00. 
     * For best results it should not be more than one month in the past nor more than six months in the future.  
     * See [here](./concepts/date-and-time) for more information on the relevance of date and time.
     * @type {Date}
     * @memberof Options
     */
    startTime?: Date | null;
    /**
     * Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
     * This field is mutually exclusive with **startTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor
     * when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified.
     * If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint.
     * Responses will contain the offset to UTC specified in the request or that of the destination waypoint.
     * The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00. 
     * For best results it should not be more than one month in the past nor more than six months in the future.  
     * See [here](./concepts/date-and-time) for more information on the relevance of date and time.
     * @type {Date}
     * @memberof Options
     */
    arrivalTime?: Date | null;
    /**
     * 
     * @type {TrafficMode}
     * @memberof Options
     */
    trafficMode?: TrafficMode;
    /**
     * The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_.
     * Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php)
     * code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).  
     * The **warningCode** `ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE` is returned if the language is not supported for maneuvers.
     * @type {string}
     * @memberof Options
     */
    language?: string;
    /**
     * 
     * @type {PolylineFormat}
     * @memberof Options
     */
    polylineFormat?: PolylineFormat;
    /**
     * The list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed,
     * i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**.
     * Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
     * @type {Array<string>}
     * @memberof Options
     */
    allowedCountries?: Array<string> | null;
    /**
     * The list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed,
     * i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**.
     * Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
     * @type {Array<string>}
     * @memberof Options
     */
    prohibitedCountries?: Array<string> | null;
    /**
     * The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).  
     * If it is not specified, the currency is taken from the **profile**.  
     * It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for 
     * toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used 
     * when setting **options[routingMode]=MONETARY**.
     * @type {string}
     * @memberof Options
     */
    currency?: string | null;
    /**
     * Specifies that the route is constructed such that turns to the passenger side are preferred.
     * @type {boolean}
     * @memberof Options
     */
    preferTurnsOnPassengerSide?: boolean;
    /**
     * Comma-separated list of features which should be avoided on the route.
     * Avoided features could be included in a route if there is no possibility to reach the target otherwise.
     * * `TOLL` - Avoid roads with toll.
     * * `FERRIES` - Avoid ferries. Ferries which cannot be avoided can be requested with `COMBINED_TRANSPORT_EVENTS` and will appear with the type `BOAT`.
     * * `RAIL_SHUTTLES` - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with `COMBINED_TRANSPORT_EVENTS` and will appear with the type `RAIL`.  
     * Cannot be used with **options[routingMode]=MONETARY**.
     * @type {Array<AvoidFeature>}
     * @memberof Options
     */
    avoid?: Array<AvoidFeature> | null;
    /**
     * Pipe-separated list of polylines.  
     * Roads and combined transports that intersect the given polylines will be considered as blocked by the routing engine.
     * If they have to be used to connect two waypoints then the route will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested.  
     * Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma.  
     * Format: `<poly1_lat1>,<poly1_lon1>,...,<poly1_latN>,<poly1_lonN>|<poly2_lat1>,<poly2_lon1>,...,<poly2_latN>,<poly2_lonN>|...`  
     * Notes:
     * * Be aware of the URL length restrictions.
     * * Requests will be rejected if at least one provided polyline
     *   * does not consist of an even number of coordinates,
     *   * contains invalid coordinates or
     *   * intersects more than 5000 road segments.
     * @type {string}
     * @memberof Options
     */
    blockIntersectingRoads?: string | null;
    /**
     * 
     * @type {RoutingMode}
     * @memberof Options
     */
    routingMode?: RoutingMode;
}

/**
 * Check if a given object implements the Options interface.
 */
export function instanceOfOptions(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function OptionsFromJSON(json: any): Options {
    return OptionsFromJSONTyped(json, false);
}

export function OptionsFromJSONTyped(json: any, ignoreDiscriminator: boolean): Options {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'startTime': !exists(json, 'startTime') ? undefined : (json['startTime'] === null ? null : new Date(json['startTime'])),
        'arrivalTime': !exists(json, 'arrivalTime') ? undefined : (json['arrivalTime'] === null ? null : new Date(json['arrivalTime'])),
        'trafficMode': !exists(json, 'trafficMode') ? undefined : TrafficModeFromJSON(json['trafficMode']),
        'language': !exists(json, 'language') ? undefined : json['language'],
        'polylineFormat': !exists(json, 'polylineFormat') ? undefined : PolylineFormatFromJSON(json['polylineFormat']),
        'allowedCountries': !exists(json, 'allowedCountries') ? undefined : json['allowedCountries'],
        'prohibitedCountries': !exists(json, 'prohibitedCountries') ? undefined : json['prohibitedCountries'],
        'currency': !exists(json, 'currency') ? undefined : json['currency'],
        'preferTurnsOnPassengerSide': !exists(json, 'preferTurnsOnPassengerSide') ? undefined : json['preferTurnsOnPassengerSide'],
        'avoid': !exists(json, 'avoid') ? undefined : (json['avoid'] === null ? null : (json['avoid'] as Array<any>).map(AvoidFeatureFromJSON)),
        'blockIntersectingRoads': !exists(json, 'blockIntersectingRoads') ? undefined : json['blockIntersectingRoads'],
        'routingMode': !exists(json, 'routingMode') ? undefined : RoutingModeFromJSON(json['routingMode']),
    };
}

export function OptionsToJSON(value?: Options | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'startTime': value.startTime === undefined ? undefined : (value.startTime === null ? null : value.startTime.toISOString()),
        'arrivalTime': value.arrivalTime === undefined ? undefined : (value.arrivalTime === null ? null : value.arrivalTime.toISOString()),
        'trafficMode': TrafficModeToJSON(value.trafficMode),
        'language': value.language,
        'polylineFormat': PolylineFormatToJSON(value.polylineFormat),
        'allowedCountries': value.allowedCountries,
        'prohibitedCountries': value.prohibitedCountries,
        'currency': value.currency,
        'preferTurnsOnPassengerSide': value.preferTurnsOnPassengerSide,
        'avoid': value.avoid === undefined ? undefined : (value.avoid === null ? null : (value.avoid as Array<any>).map(AvoidFeatureToJSON)),
        'blockIntersectingRoads': value.blockIntersectingRoads,
        'routingMode': RoutingModeToJSON(value.routingMode),
    };
}

