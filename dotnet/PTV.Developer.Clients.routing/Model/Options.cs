/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.32
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routing.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routing.Model
{
    /// <summary>
    /// Options
    /// </summary>
    [DataContract(Name = "Options")]
    public partial class Options : IValidatableObject
    {

        /// <summary>
        /// Gets or Sets TrafficMode
        /// </summary>
        [DataMember(Name = "trafficMode", EmitDefaultValue = true)]
        public TrafficMode? TrafficMode { get; set; }

        /// <summary>
        /// Gets or Sets PolylineFormat
        /// </summary>
        [DataMember(Name = "polylineFormat", EmitDefaultValue = true)]
        public PolylineFormat? PolylineFormat { get; set; }

        /// <summary>
        /// Gets or Sets RoutingMode
        /// </summary>
        [DataMember(Name = "routingMode", EmitDefaultValue = true)]
        public RoutingMode? RoutingMode { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Options" /> class.
        /// </summary>
        /// <param name="startTime">Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_.  This field is mutually exclusive with **arrivalTime** and **tollTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the start waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time..</param>
        /// <param name="arrivalTime">Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This field is mutually exclusive with **startTime** and **tollTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the destination waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time..</param>
        /// <param name="tollTime">Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with both **startTime** and **arrivalTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/date-and-time) for more information on the relevance of date and time..</param>
        /// <param name="trafficMode">trafficMode.</param>
        /// <param name="language">The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_. Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).   The **warningCode** _ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE_ is returned if the language is not supported for maneuvers. (default to &quot;en&quot;).</param>
        /// <param name="polylineFormat">polylineFormat.</param>
        /// <param name="allowedCountries">Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision..</param>
        /// <param name="prohibitedCountries">Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision..</param>
        /// <param name="currency">The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).   If it is not specified, the currency is taken from the **profile**.   It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for  toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used  when setting **options[routingMode]&#x3D;MONETARY**..</param>
        /// <param name="preferTurnsOnPassengerSide">Specifies that the route is constructed such that turns to the passenger side are preferred.  (default to false).</param>
        /// <param name="avoid">Comma-separated list of features which should be avoided on the route. Avoided features could be included in a route if there is no possibility to reach the target otherwise. * &#x60;TOLL&#x60; - Avoid roads with toll. * &#x60;FERRIES&#x60; - Avoid ferries. Ferries which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _BOAT_. * &#x60;RAIL_SHUTTLES&#x60; - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _RAIL_. * &#x60;HIGHWAYS&#x60; - Avoid highways and motorways. Waypoints will not be matched to highways, they will be matched to the nearest road which is not a highway. Cannot be used with **options[routingMode]&#x3D;MONETARY**.  See [here](./concepts/avoid) for more information.   Available values are provided by type &#x60;AvoidFeature&#x60;..</param>
        /// <param name="blockIntersectingRoads">Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. .</param>
        /// <param name="customRoadAttributeScenarios">Comma-separated list of [custom road attribute scenarios](../data-api/concepts/custom-road-attributes) to be considered in the route calculation.  Each scenario can be specified by its name or its ID. A shared scenario can only be specified by its ID.  The size limitations that apply to each scenario, also apply to the collection of scenarios, i.e. the limit  on the number of roads in one scenario can not be circumvented by splitting it in multiple scenarios..</param>
        /// <param name="routingMode">routingMode.</param>
        /// <param name="maximumSpeed">The maximum speed of the vehicle [km/h]. The speeds for calculating the driving times on all roads will be limited to this value.  See [here](./concepts/speeds) for more information..</param>
        /// <param name="speedFactor">An additional factor to apply to the speed of the vehicle. This modified speed is used to modify the driving times after the route has been calculated. That means in particular that the route itself will not be modified by applying a speed factor. When lower than one, the driving time of the vehicle will increase, when greater than one, the driving time of the vehicle will decrease. Note that the factor is only applied on the parts of the route where the vehicle is driving. Therefore, a speed factor of 1.1 does not necessarily mean that the **travelTime** of the resulting route will be 10% faster. The speed is not capped by the maximum speed of the  vehicle or of the road.  See [here](./concepts/speeds) for more information. (default to 1D).</param>
        public Options(DateTimeOffset? startTime = default(DateTimeOffset?), DateTimeOffset? arrivalTime = default(DateTimeOffset?), DateTimeOffset? tollTime = default(DateTimeOffset?), TrafficMode? trafficMode = default(TrafficMode?), string language = @"en", PolylineFormat? polylineFormat = default(PolylineFormat?), string allowedCountries = default(string), string prohibitedCountries = default(string), string currency = default(string), bool? preferTurnsOnPassengerSide = false, string avoid = default(string), string blockIntersectingRoads = default(string), string customRoadAttributeScenarios = default(string), RoutingMode? routingMode = default(RoutingMode?), int? maximumSpeed = default(int?), double? speedFactor = 1D)
        {
            this.StartTime = startTime;
            this.ArrivalTime = arrivalTime;
            this.TollTime = tollTime;
            this.TrafficMode = trafficMode;
            // use default value if no "language" provided
            this.Language = language ?? @"en";
            this.PolylineFormat = polylineFormat;
            this.AllowedCountries = allowedCountries;
            this.ProhibitedCountries = prohibitedCountries;
            this.Currency = currency;
            // use default value if no "preferTurnsOnPassengerSide" provided
            this.PreferTurnsOnPassengerSide = preferTurnsOnPassengerSide ?? false;
            this.Avoid = avoid;
            this.BlockIntersectingRoads = blockIntersectingRoads;
            this.CustomRoadAttributeScenarios = customRoadAttributeScenarios;
            this.RoutingMode = routingMode;
            this.MaximumSpeed = maximumSpeed;
            // use default value if no "speedFactor" provided
            this.SpeedFactor = speedFactor ?? 1D;
        }

        /// <summary>
        /// Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_.  This field is mutually exclusive with **arrivalTime** and **tollTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the start waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
        /// </summary>
        /// <value>Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_.  This field is mutually exclusive with **arrivalTime** and **tollTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the start waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.</value>
        /// <example>2020-12-04T06:00Z</example>
        [DataMember(Name = "startTime", EmitDefaultValue = true)]
        public DateTimeOffset? StartTime { get; set; }

        /// <summary>
        /// Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This field is mutually exclusive with **startTime** and **tollTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the destination waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
        /// </summary>
        /// <value>Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This field is mutually exclusive with **startTime** and **tollTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request or that of the destination waypoint. For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.</value>
        [DataMember(Name = "arrivalTime", EmitDefaultValue = true)]
        public DateTimeOffset? ArrivalTime { get; set; }

        /// <summary>
        /// Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with both **startTime** and **arrivalTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
        /// </summary>
        /// <value>Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).  This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with both **startTime** and **arrivalTime**. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.</value>
        [DataMember(Name = "tollTime", EmitDefaultValue = true)]
        public DateTimeOffset? TollTime { get; set; }

        /// <summary>
        /// The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_. Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).   The **warningCode** _ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE_ is returned if the language is not supported for maneuvers.
        /// </summary>
        /// <value>The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_. Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).   The **warningCode** _ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE_ is returned if the language is not supported for maneuvers.</value>
        [DataMember(Name = "language", EmitDefaultValue = true)]
        public string Language { get; set; }

        /// <summary>
        /// Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "allowedCountries", EmitDefaultValue = true)]
        public string AllowedCountries { get; set; }

        /// <summary>
        /// Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "prohibitedCountries", EmitDefaultValue = true)]
        public string ProhibitedCountries { get; set; }

        /// <summary>
        /// The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).   If it is not specified, the currency is taken from the **profile**.   It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for  toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used  when setting **options[routingMode]&#x3D;MONETARY**.
        /// </summary>
        /// <value>The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).   If it is not specified, the currency is taken from the **profile**.   It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for  toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used  when setting **options[routingMode]&#x3D;MONETARY**.</value>
        [DataMember(Name = "currency", EmitDefaultValue = true)]
        public string Currency { get; set; }

        /// <summary>
        /// Specifies that the route is constructed such that turns to the passenger side are preferred. 
        /// </summary>
        /// <value>Specifies that the route is constructed such that turns to the passenger side are preferred. </value>
        /// <example>false</example>
        [DataMember(Name = "preferTurnsOnPassengerSide", EmitDefaultValue = true)]
        public bool? PreferTurnsOnPassengerSide { get; set; }

        /// <summary>
        /// Comma-separated list of features which should be avoided on the route. Avoided features could be included in a route if there is no possibility to reach the target otherwise. * &#x60;TOLL&#x60; - Avoid roads with toll. * &#x60;FERRIES&#x60; - Avoid ferries. Ferries which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _BOAT_. * &#x60;RAIL_SHUTTLES&#x60; - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _RAIL_. * &#x60;HIGHWAYS&#x60; - Avoid highways and motorways. Waypoints will not be matched to highways, they will be matched to the nearest road which is not a highway. Cannot be used with **options[routingMode]&#x3D;MONETARY**.  See [here](./concepts/avoid) for more information.   Available values are provided by type &#x60;AvoidFeature&#x60;.
        /// </summary>
        /// <value>Comma-separated list of features which should be avoided on the route. Avoided features could be included in a route if there is no possibility to reach the target otherwise. * &#x60;TOLL&#x60; - Avoid roads with toll. * &#x60;FERRIES&#x60; - Avoid ferries. Ferries which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _BOAT_. * &#x60;RAIL_SHUTTLES&#x60; - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with _COMBINED_TRANSPORT_EVENTS_ and will appear with the type _RAIL_. * &#x60;HIGHWAYS&#x60; - Avoid highways and motorways. Waypoints will not be matched to highways, they will be matched to the nearest road which is not a highway. Cannot be used with **options[routingMode]&#x3D;MONETARY**.  See [here](./concepts/avoid) for more information.   Available values are provided by type &#x60;AvoidFeature&#x60;.</value>
        [DataMember(Name = "avoid", EmitDefaultValue = true)]
        public string Avoid { get; set; }

        /// <summary>
        /// Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. 
        /// </summary>
        /// <value>Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. </value>
        /// <example>49.8,9.9,49.9,10|33.1,-111.1,33.0,-111.2</example>
        [DataMember(Name = "blockIntersectingRoads", EmitDefaultValue = true)]
        public string BlockIntersectingRoads { get; set; }

        /// <summary>
        /// Comma-separated list of [custom road attribute scenarios](../data-api/concepts/custom-road-attributes) to be considered in the route calculation.  Each scenario can be specified by its name or its ID. A shared scenario can only be specified by its ID.  The size limitations that apply to each scenario, also apply to the collection of scenarios, i.e. the limit  on the number of roads in one scenario can not be circumvented by splitting it in multiple scenarios.
        /// </summary>
        /// <value>Comma-separated list of [custom road attribute scenarios](../data-api/concepts/custom-road-attributes) to be considered in the route calculation.  Each scenario can be specified by its name or its ID. A shared scenario can only be specified by its ID.  The size limitations that apply to each scenario, also apply to the collection of scenarios, i.e. the limit  on the number of roads in one scenario can not be circumvented by splitting it in multiple scenarios.</value>
        [DataMember(Name = "customRoadAttributeScenarios", EmitDefaultValue = true)]
        public string CustomRoadAttributeScenarios { get; set; }

        /// <summary>
        /// The maximum speed of the vehicle [km/h]. The speeds for calculating the driving times on all roads will be limited to this value.  See [here](./concepts/speeds) for more information.
        /// </summary>
        /// <value>The maximum speed of the vehicle [km/h]. The speeds for calculating the driving times on all roads will be limited to this value.  See [here](./concepts/speeds) for more information.</value>
        [DataMember(Name = "maximumSpeed", EmitDefaultValue = true)]
        public int? MaximumSpeed { get; set; }

        /// <summary>
        /// An additional factor to apply to the speed of the vehicle. This modified speed is used to modify the driving times after the route has been calculated. That means in particular that the route itself will not be modified by applying a speed factor. When lower than one, the driving time of the vehicle will increase, when greater than one, the driving time of the vehicle will decrease. Note that the factor is only applied on the parts of the route where the vehicle is driving. Therefore, a speed factor of 1.1 does not necessarily mean that the **travelTime** of the resulting route will be 10% faster. The speed is not capped by the maximum speed of the  vehicle or of the road.  See [here](./concepts/speeds) for more information.
        /// </summary>
        /// <value>An additional factor to apply to the speed of the vehicle. This modified speed is used to modify the driving times after the route has been calculated. That means in particular that the route itself will not be modified by applying a speed factor. When lower than one, the driving time of the vehicle will increase, when greater than one, the driving time of the vehicle will decrease. Note that the factor is only applied on the parts of the route where the vehicle is driving. Therefore, a speed factor of 1.1 does not necessarily mean that the **travelTime** of the resulting route will be 10% faster. The speed is not capped by the maximum speed of the  vehicle or of the road.  See [here](./concepts/speeds) for more information.</value>
        /// <example>1.1</example>
        [DataMember(Name = "speedFactor", EmitDefaultValue = true)]
        public double? SpeedFactor { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Options {\n");
            sb.Append("  StartTime: ").Append(StartTime).Append("\n");
            sb.Append("  ArrivalTime: ").Append(ArrivalTime).Append("\n");
            sb.Append("  TollTime: ").Append(TollTime).Append("\n");
            sb.Append("  TrafficMode: ").Append(TrafficMode).Append("\n");
            sb.Append("  Language: ").Append(Language).Append("\n");
            sb.Append("  PolylineFormat: ").Append(PolylineFormat).Append("\n");
            sb.Append("  AllowedCountries: ").Append(AllowedCountries).Append("\n");
            sb.Append("  ProhibitedCountries: ").Append(ProhibitedCountries).Append("\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  PreferTurnsOnPassengerSide: ").Append(PreferTurnsOnPassengerSide).Append("\n");
            sb.Append("  Avoid: ").Append(Avoid).Append("\n");
            sb.Append("  BlockIntersectingRoads: ").Append(BlockIntersectingRoads).Append("\n");
            sb.Append("  CustomRoadAttributeScenarios: ").Append(CustomRoadAttributeScenarios).Append("\n");
            sb.Append("  RoutingMode: ").Append(RoutingMode).Append("\n");
            sb.Append("  MaximumSpeed: ").Append(MaximumSpeed).Append("\n");
            sb.Append("  SpeedFactor: ").Append(SpeedFactor).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.Language != null) {
                // Language (string) pattern
                Regex regexLanguage = new Regex(@"[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*", RegexOptions.CultureInvariant);
                if (!regexLanguage.Match(this.Language).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Language, must match a pattern of " + regexLanguage, new [] { "Language" });
                }
            }

            if (this.Currency != null) {
                // Currency (string) pattern
                Regex regexCurrency = new Regex(@"[A-Z]{3}", RegexOptions.CultureInvariant);
                if (!regexCurrency.Match(this.Currency).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Currency, must match a pattern of " + regexCurrency, new [] { "Currency" });
                }
            }

            // MaximumSpeed (int?) minimum
            if (this.MaximumSpeed < (int?)1)
            {
                yield return new ValidationResult("Invalid value for MaximumSpeed, must be a value greater than or equal to 1.", new [] { "MaximumSpeed" });
            }

            // SpeedFactor (double?) maximum
            if (this.SpeedFactor > (double?)10)
            {
                yield return new ValidationResult("Invalid value for SpeedFactor, must be a value less than or equal to 10.", new [] { "SpeedFactor" });
            }

            // SpeedFactor (double?) minimum
            if (this.SpeedFactor < (double?)0.1)
            {
                yield return new ValidationResult("Invalid value for SpeedFactor, must be a value greater than or equal to 0.1.", new [] { "SpeedFactor" });
            }

            yield break;
        }
    }

}
