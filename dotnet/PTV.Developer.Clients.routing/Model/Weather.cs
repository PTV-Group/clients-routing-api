/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.32
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routing.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routing.Model
{
    /// <summary>
    /// The weather at a waypoint. It is relevant to the electricity consumption calculation of electric vehicles. The  weather is valid until the end of the route unless it is changed again at a subsequent waypoint. If no weather  is configured at any waypoint, the weather is automatically determined using the [OpenMeteo](https://open-meteo.com)  weather service. This is only available if the time of the route is no more than 14 days in the future. If the routing is outside of this time box and no weather is configured at any waypoint, a temperature of 23째C and no  wind is assumed for minimal impact on the consumption calculation. The parameter **windDirection** must not be null if **windSpeed** is set to anything but 0. 
    /// </summary>
    [DataContract(Name = "Weather")]
    public partial class Weather : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Weather" /> class.
        /// </summary>
        /// <param name="temperature">The average temperature at a waypoint at 2 meters above ground[째C]. Used to estimate the state of health of the  battery and consumption due to air conditioning..</param>
        /// <param name="windSpeed">The average wind speed at a waypoint at 10 meters above ground [km/h]..</param>
        /// <param name="windDirection">The wind direction (clockwise) at 10 meters above ground. North represents 0 degrees..</param>
        public Weather(double? temperature = default(double?), int? windSpeed = default(int?), int? windDirection = default(int?))
        {
            this.Temperature = temperature;
            this.WindSpeed = windSpeed;
            this.WindDirection = windDirection;
        }

        /// <summary>
        /// The average temperature at a waypoint at 2 meters above ground[째C]. Used to estimate the state of health of the  battery and consumption due to air conditioning.
        /// </summary>
        /// <value>The average temperature at a waypoint at 2 meters above ground[째C]. Used to estimate the state of health of the  battery and consumption due to air conditioning.</value>
        [DataMember(Name = "temperature", EmitDefaultValue = true)]
        public double? Temperature { get; set; }

        /// <summary>
        /// The average wind speed at a waypoint at 10 meters above ground [km/h].
        /// </summary>
        /// <value>The average wind speed at a waypoint at 10 meters above ground [km/h].</value>
        [DataMember(Name = "windSpeed", EmitDefaultValue = true)]
        public int? WindSpeed { get; set; }

        /// <summary>
        /// The wind direction (clockwise) at 10 meters above ground. North represents 0 degrees.
        /// </summary>
        /// <value>The wind direction (clockwise) at 10 meters above ground. North represents 0 degrees.</value>
        [DataMember(Name = "windDirection", EmitDefaultValue = true)]
        public int? WindDirection { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Weather {\n");
            sb.Append("  Temperature: ").Append(Temperature).Append("\n");
            sb.Append("  WindSpeed: ").Append(WindSpeed).Append("\n");
            sb.Append("  WindDirection: ").Append(WindDirection).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Temperature (double?) maximum
            if (this.Temperature > (double?)70)
            {
                yield return new ValidationResult("Invalid value for Temperature, must be a value less than or equal to 70.", new [] { "Temperature" });
            }

            // Temperature (double?) minimum
            if (this.Temperature < (double?)-50)
            {
                yield return new ValidationResult("Invalid value for Temperature, must be a value greater than or equal to -50.", new [] { "Temperature" });
            }

            // WindSpeed (int?) minimum
            if (this.WindSpeed < (int?)0)
            {
                yield return new ValidationResult("Invalid value for WindSpeed, must be a value greater than or equal to 0.", new [] { "WindSpeed" });
            }

            yield break;
        }
    }

}
