/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, drivers' working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.32
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.routing.Client;
using PTV.Developer.Clients.routing.Model;

namespace PTV.Developer.Clients.routing.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreas</returns>
        ReachableAreas CalculateReachableAreas(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreas</returns>
        ApiResponse<ReachableAreas> CalculateReachableAreasWithHttpInfo(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteReachableAreas(Guid? id, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteReachableAreasWithHttpInfo(Guid? id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasResponse</returns>
        ReachableAreasResponse GetReachableAreas(Guid? id, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasResponse</returns>
        ApiResponse<ReachableAreasResponse> GetReachableAreasWithHttpInfo(Guid? id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasId</returns>
        ReachableAreasId StartAndCreateReachableAreas(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasId</returns>
        ApiResponse<ReachableAreasId> StartAndCreateReachableAreasWithHttpInfo(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreas</returns>
        System.Threading.Tasks.Task<ReachableAreas> CalculateReachableAreasAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreas)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreas>> CalculateReachableAreasWithHttpInfoAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteReachableAreasAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteReachableAreasWithHttpInfoAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasResponse</returns>
        System.Threading.Tasks.Task<ReachableAreasResponse> GetReachableAreasAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreasResponse>> GetReachableAreasWithHttpInfoAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasId</returns>
        System.Threading.Tasks.Task<ReachableAreasId> StartAndCreateReachableAreasAsync(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasId)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreasId>> StartAndCreateReachableAreasWithHttpInfoAsync(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApi : IReachableAreasApiSync, IReachableAreasApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ReachableAreasApi : IReachableAreasApi
    {
        private PTV.Developer.Clients.routing.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableAreasApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableAreasApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.routing.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.routing.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ReachableAreasApi(PTV.Developer.Clients.routing.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.routing.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ReachableAreasApi(PTV.Developer.Clients.routing.Client.ISynchronousClient client, PTV.Developer.Clients.routing.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.routing.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.routing.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreas</returns>
        public ReachableAreas CalculateReachableAreas(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreas> localVarResponse = CalculateReachableAreasWithHttpInfo(waypoint, horizons, profile, horizonType, options);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreas</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreas> CalculateReachableAreasWithHttpInfo(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->CalculateReachableAreas");
            }

            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->CalculateReachableAreas");
            }

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.CalculateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableAreas>("/reachable-areas", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreas</returns>
        public async System.Threading.Tasks.Task<ReachableAreas> CalculateReachableAreasAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreas> localVarResponse = await CalculateReachableAreasWithHttpInfoAsync(waypoint, horizons, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreas)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreas>> CalculateReachableAreasWithHttpInfoAsync(string waypoint, List<int?> horizons, string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->CalculateReachableAreas");
            }

            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->CalculateReachableAreas");
            }


            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.CalculateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableAreas>("/reachable-areas", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteReachableAreas(Guid? id, int operationIndex = 0)
        {
            DeleteReachableAreasWithHttpInfo(id);
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<Object> DeleteReachableAreasWithHttpInfo(Guid? id, int operationIndex = 0)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->DeleteReachableAreas");
            }

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableAreasApi.DeleteReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteReachableAreasAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            await DeleteReachableAreasWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Cancels a reachable areas calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<Object>> DeleteReachableAreasWithHttpInfoAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->DeleteReachableAreas");
            }


            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableAreasApi.DeleteReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasResponse</returns>
        public ReachableAreasResponse GetReachableAreas(Guid? id, int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasResponse> localVarResponse = GetReachableAreasWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasResponse</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasResponse> GetReachableAreasWithHttpInfo(Guid? id, int operationIndex = 0)
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->GetReachableAreas");
            }

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableAreasApi.GetReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableAreasResponse>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasResponse</returns>
        public async System.Threading.Tasks.Task<ReachableAreasResponse> GetReachableAreasAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasResponse> localVarResponse = await GetReachableAreasWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasResponse>> GetReachableAreasWithHttpInfoAsync(Guid? id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'id' when calling ReachableAreasApi->GetReachableAreas");
            }


            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableAreasApi.GetReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableAreasResponse>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasId</returns>
        public ReachableAreasId StartAndCreateReachableAreas(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasId> localVarResponse = StartAndCreateReachableAreasWithHttpInfo(horizons, waypoint, routeId, profile, horizonType, options);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasId</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasId> StartAndCreateReachableAreasWithHttpInfo(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.StartAndCreateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ReachableAreasId>("/reachable-areas", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasId</returns>
        public async System.Threading.Tasks.Task<ReachableAreasId> StartAndCreateReachableAreasAsync(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasId> localVarResponse = await StartAndCreateReachableAreasWithHttpInfoAsync(horizons, waypoint, routeId, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the **horizons** parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasId)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<ReachableAreasId>> StartAndCreateReachableAreasWithHttpInfoAsync(List<int?> horizons, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }


            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }

            localVarRequestOptions.Operation = "ReachableAreasApi.StartAndCreateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReachableAreasId>("/reachable-areas", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
