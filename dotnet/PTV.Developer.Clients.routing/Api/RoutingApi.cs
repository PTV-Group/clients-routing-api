/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.27
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.routing.Client;
using PTV.Developer.Clients.routing.Model;

namespace PTV.Developer.Clients.routing.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        RouteResponse CalculateRoute(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        ApiResponse<RouteResponse> CalculateRouteWithHttpInfo(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        RouteResponse CalculateRoutePost(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        ApiResponse<RouteResponse> CalculateRoutePostWithHttpInfo(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EtaResponse</returns>
        EtaResponse GetEstimatedTimeOfArrival(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EtaResponse</returns>
        ApiResponse<EtaResponse> GetEstimatedTimeOfArrivalWithHttpInfo(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        RouteResponse GetRouteByRouteId(Guid routeId, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        ApiResponse<RouteResponse> GetRouteByRouteIdWithHttpInfo(Guid routeId, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        System.Threading.Tasks.Task<RouteResponse> CalculateRouteAsync(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RouteResponse>> CalculateRouteWithHttpInfoAsync(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        System.Threading.Tasks.Task<RouteResponse> CalculateRoutePostAsync(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RouteResponse>> CalculateRoutePostWithHttpInfoAsync(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EtaResponse</returns>
        System.Threading.Tasks.Task<EtaResponse> GetEstimatedTimeOfArrivalAsync(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EtaResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EtaResponse>> GetEstimatedTimeOfArrivalWithHttpInfoAsync(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        System.Threading.Tasks.Task<RouteResponse> GetRouteByRouteIdAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RouteResponse>> GetRouteByRouteIdWithHttpInfoAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApi : IRoutingApiSync, IRoutingApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class RoutingApi : IRoutingApi
    {
        private PTV.Developer.Clients.routing.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RoutingApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RoutingApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.routing.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.routing.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public RoutingApi(PTV.Developer.Clients.routing.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.routing.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public RoutingApi(PTV.Developer.Clients.routing.Client.ISynchronousClient client, PTV.Developer.Clients.routing.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.routing.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.routing.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        public RouteResponse CalculateRoute(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> localVarResponse = CalculateRouteWithHttpInfo(waypoints, routeId, profile, vehicle, options, emissionOptions, monetaryCostOptions, results);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> CalculateRouteWithHttpInfo(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoints != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("multi", "waypoints", waypoints));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.LowEmissionZoneApprovals != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneApprovals]", vehicle.LowEmissionZoneApprovals));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.TotalTechnicallyPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalTechnicallyPermittedWeight]", vehicle.TotalTechnicallyPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TollTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[tollTime]", options.TollTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (emissionOptions != null)
            {
                if (emissionOptions.CalculationMethods != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[calculationMethods]", emissionOptions.CalculationMethods));
                }
                if (emissionOptions.DefaultConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[defaultConsumption]", emissionOptions.DefaultConsumption));
                }
                if (emissionOptions.Iso14083EmissionFactorsVersion != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[iso14083EmissionFactorsVersion]", emissionOptions.Iso14083EmissionFactorsVersion));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }

            localVarRequestOptions.Operation = "RoutingApi.CalculateRoute";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<RouteResponse>("/routes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoute", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        public async System.Threading.Tasks.Task<RouteResponse> CalculateRouteAsync(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> localVarResponse = await CalculateRouteWithHttpInfoAsync(waypoints, routeId, profile, vehicle, options, emissionOptions, monetaryCostOptions, results, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse>> CalculateRouteWithHttpInfoAsync(List<string>? waypoints = default(List<string>?), Guid? routeId = default(Guid?), string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoints != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("multi", "waypoints", waypoints));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.LowEmissionZoneApprovals != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneApprovals]", vehicle.LowEmissionZoneApprovals));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.TotalTechnicallyPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalTechnicallyPermittedWeight]", vehicle.TotalTechnicallyPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TollTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[tollTime]", options.TollTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (emissionOptions != null)
            {
                if (emissionOptions.CalculationMethods != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[calculationMethods]", emissionOptions.CalculationMethods));
                }
                if (emissionOptions.DefaultConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[defaultConsumption]", emissionOptions.DefaultConsumption));
                }
                if (emissionOptions.Iso14083EmissionFactorsVersion != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[iso14083EmissionFactorsVersion]", emissionOptions.Iso14083EmissionFactorsVersion));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }

            localVarRequestOptions.Operation = "RoutingApi.CalculateRoute";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<RouteResponse>("/routes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoute", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        public RouteResponse CalculateRoutePost(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> localVarResponse = CalculateRoutePostWithHttpInfo(routeRequest, profile, vehicle, driver, options, emissionOptions, monetaryCostOptions, evOptions, results);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> CalculateRoutePostWithHttpInfo(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0)
        {
            // verify the required parameter 'routeRequest' is set
            if (routeRequest == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'routeRequest' when calling RoutingApi->CalculateRoutePost");
            }

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.LowEmissionZoneApprovals != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneApprovals]", vehicle.LowEmissionZoneApprovals));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.TotalTechnicallyPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalTechnicallyPermittedWeight]", vehicle.TotalTechnicallyPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (driver != null)
            {
                if (driver.WorkingHoursPreset != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "driver[workingHoursPreset]", driver.WorkingHoursPreset));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TollTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[tollTime]", options.TollTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (emissionOptions != null)
            {
                if (emissionOptions.CalculationMethods != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[calculationMethods]", emissionOptions.CalculationMethods));
                }
                if (emissionOptions.DefaultConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[defaultConsumption]", emissionOptions.DefaultConsumption));
                }
                if (emissionOptions.Iso14083EmissionFactorsVersion != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[iso14083EmissionFactorsVersion]", emissionOptions.Iso14083EmissionFactorsVersion));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (evOptions != null)
            {
                if (evOptions.InitialStateOfCharge != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "evOptions[initialStateOfCharge]", evOptions.InitialStateOfCharge));
                }
                if (evOptions.MinimumStateOfCharge != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "evOptions[minimumStateOfCharge]", evOptions.MinimumStateOfCharge));
                }
                if (evOptions.EnergyEfficientRoute != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "evOptions[energyEfficientRoute]", evOptions.EnergyEfficientRoute));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            localVarRequestOptions.Data = routeRequest;

            localVarRequestOptions.Operation = "RoutingApi.CalculateRoutePost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<RouteResponse>("/routes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoutePost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        public async System.Threading.Tasks.Task<RouteResponse> CalculateRoutePostAsync(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> localVarResponse = await CalculateRoutePostWithHttpInfoAsync(routeRequest, profile, vehicle, driver, options, emissionOptions, monetaryCostOptions, evOptions, results, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must either be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_ or a UUID of a predefined [vehicle model](../data-api/code-samples/vehicle-models) from the Data API.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If a model of an electric vehicle is used, the electricity consumption of the concrete vehicle model can be calculated. Some parameters like **vehicle[engineType]** cannot be used with a model of an electric vehicle. Those parameters are automatically filled as applicable from the selected model.  Please refer to the [concept](./concepts/model-based-ev-consumption-calculation) to see specifically which parameters are not compatible. These vehicle model profiles are in a preview state, the API is stable, feature changes could be introduced in future.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only).  The values of the predefined profiles may be adapted to reflect current vehicle standards. To obtain the same results when values change, it is recommended to  always send with the request the **vehicle** parameters that are important for your use case. (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="emissionOptions">Relevant options to report emissions. Use array notation like &#x60;emissionOptions[calculationMethods]&#x3D;ISO14083_2023&#x60; to set options.  This parameter supersedes emission-related values in **results**.  If specified the emission-related values in **results** will be ignored. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="evOptions">Relevant options to report the electricity consumption of an electric vehicle along a route when _EV_REPORT_, _EV_STATUS_EVENTS_, _EV_STATUS_EVENTS_POLYLINE_ or _EV_CHARGE_EVENTS_ are requested in the **results**. Use array notation like &#x60;evOptions[initialStateOfCharge]&#x3D;100&#x60; to set options.  This parameter is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  **Main results:**  * &#x60;ROUTE_ID&#x60;     Response includes the route ID. See [here](./concepts/waypoints) for more information.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information.  **Toll-related results:**  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  **Events:**  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;LOW_EMISSION_ZONE_EVENTS&#x60;      Response includes **events** when a low-emission zone is entered or exited by the route.  **Emission-related results:**  These results are superseded by the parameter **emissionOptions**.  If **emissionOptions** is specified the emission-related results will be ignored.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission calculation method which should only be used with [European profiles](../data-api/concepts/profiles).  **Results available only in the POST operation:**  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**).  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times.  * &#x60;EV_REPORT&#x60;     Response includes a report with detailed electricity consumption for electric vehicles for the route and, if they are requested, for legs. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS&#x60;     Response includes events reporting the electricity consumption along the route in more detail. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_STATUS_EVENTS_POLYLINE&#x60;     Response includes the polyline for each **evStatus**-event since the previous **evStatus**-event. _EV_STATUS_EVENTS_ will automatically be included. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future.  * &#x60;EV_CHARGE_EVENTS&#x60;     Response includes events proposing where the battery of the electric vehicle should be charged. The charging time is a proposal, currently for information only. It is not included in the travel time of the route and the start time of subsequent events is not offset by it. This is only available for concrete models of electric vehicles but not for general routing profiles (see documentation of **profile**). This result is in a preview state, the API is stable, feature changes could be introduced in future. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse>> CalculateRoutePostWithHttpInfoAsync(RouteRequest routeRequest, string? profile = default(string?), Vehicle? vehicle = default(Vehicle?), Driver? driver = default(Driver?), Options? options = default(Options?), EmissionOptions? emissionOptions = default(EmissionOptions?), MonetaryCostOptions? monetaryCostOptions = default(MonetaryCostOptions?), EvOptions? evOptions = default(EvOptions?), List<Results>? results = default(List<Results>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'routeRequest' is set
            if (routeRequest == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'routeRequest' when calling RoutingApi->CalculateRoutePost");
            }


            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.LowEmissionZoneApprovals != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneApprovals]", vehicle.LowEmissionZoneApprovals));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.TotalTechnicallyPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalTechnicallyPermittedWeight]", vehicle.TotalTechnicallyPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (driver != null)
            {
                if (driver.WorkingHoursPreset != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "driver[workingHoursPreset]", driver.WorkingHoursPreset));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TollTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[tollTime]", options.TollTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (emissionOptions != null)
            {
                if (emissionOptions.CalculationMethods != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[calculationMethods]", emissionOptions.CalculationMethods));
                }
                if (emissionOptions.DefaultConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[defaultConsumption]", emissionOptions.DefaultConsumption));
                }
                if (emissionOptions.Iso14083EmissionFactorsVersion != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "emissionOptions[iso14083EmissionFactorsVersion]", emissionOptions.Iso14083EmissionFactorsVersion));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (evOptions != null)
            {
                if (evOptions.InitialStateOfCharge != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "evOptions[initialStateOfCharge]", evOptions.InitialStateOfCharge));
                }
                if (evOptions.MinimumStateOfCharge != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "evOptions[minimumStateOfCharge]", evOptions.MinimumStateOfCharge));
                }
                if (evOptions.EnergyEfficientRoute != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "evOptions[energyEfficientRoute]", evOptions.EnergyEfficientRoute));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            localVarRequestOptions.Data = routeRequest;

            localVarRequestOptions.Operation = "RoutingApi.CalculateRoutePost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<RouteResponse>("/routes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoutePost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EtaResponse</returns>
        public EtaResponse GetEstimatedTimeOfArrival(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<EtaResponse> localVarResponse = GetEstimatedTimeOfArrivalWithHttpInfo(routeId, waypoint, position, time, workLogbook);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EtaResponse</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<EtaResponse> GetEstimatedTimeOfArrivalWithHttpInfo(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("routeId", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(routeId)); // path parameter
            if (waypoint != null)
            {
                if (waypoint.Name != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint[name]", waypoint.Name));
                }
                if (waypoint.PerformedServiceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint[performedServiceTime]", waypoint.PerformedServiceTime));
                }
            }
            if (position != null)
            {
                if (position.Latitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[latitude]", position.Latitude));
                }
                if (position.Longitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[longitude]", position.Longitude));
                }
                if (position.NextWaypointName != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[nextWaypointName]", position.NextWaypointName));
                }
                if (position.Heading != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[heading]", position.Heading));
                }
                if (position.HeadingTolerance != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[headingTolerance]", position.HeadingTolerance));
                }
            }
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (workLogbook != null)
            {
                if (workLogbook.LastTimeTheDriverWorked != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[lastTimeTheDriverWorked]", workLogbook.LastTimeTheDriverWorked));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastBreak]", workLogbook.AccumulatedDrivingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedWorkingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedWorkingTimeSinceLastBreak]", workLogbook.AccumulatedWorkingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastDailyRest]", workLogbook.AccumulatedDrivingTimeSinceLastDailyRest));
                }
                if (workLogbook.AccumulatedTravelTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedTravelTimeSinceLastDailyRest]", workLogbook.AccumulatedTravelTimeSinceLastDailyRest));
                }
            }

            localVarRequestOptions.Operation = "RoutingApi.GetEstimatedTimeOfArrival";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<EtaResponse>("/eta/{routeId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEstimatedTimeOfArrival", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EtaResponse</returns>
        public async System.Threading.Tasks.Task<EtaResponse> GetEstimatedTimeOfArrivalAsync(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<EtaResponse> localVarResponse = await GetEstimatedTimeOfArrivalWithHttpInfoAsync(routeId, waypoint, position, time, workLogbook, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the position of the vehicle.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation. See [here](./concepts/waypoints) for more information.  Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route ID. Otherwise, the route ID cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route ID must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="time">Defines the time when the vehicle position was captured formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified the current time will be used, i.e. the given position of the vehicle is its current position.  If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the position of the vehicle. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The response will contain the offset to UTC specified in the request, otherwise it will contain the offset to UTC of the position of the vehicle. For best results the time should be only several minutes in the past or in the future, otherwise live traffic will not be considered properly. (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EtaResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<EtaResponse>> GetEstimatedTimeOfArrivalWithHttpInfoAsync(Guid routeId, PositionAtWaypoint? waypoint = default(PositionAtWaypoint?), PositionOnRoute? position = default(PositionOnRoute?), DateTimeOffset? time = default(DateTimeOffset?), WorkLogbook? workLogbook = default(WorkLogbook?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("routeId", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(routeId)); // path parameter
            if (waypoint != null)
            {
                if (waypoint.Name != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint[name]", waypoint.Name));
                }
                if (waypoint.PerformedServiceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint[performedServiceTime]", waypoint.PerformedServiceTime));
                }
            }
            if (position != null)
            {
                if (position.Latitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[latitude]", position.Latitude));
                }
                if (position.Longitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[longitude]", position.Longitude));
                }
                if (position.NextWaypointName != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[nextWaypointName]", position.NextWaypointName));
                }
                if (position.Heading != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[heading]", position.Heading));
                }
                if (position.HeadingTolerance != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "position[headingTolerance]", position.HeadingTolerance));
                }
            }
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (workLogbook != null)
            {
                if (workLogbook.LastTimeTheDriverWorked != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[lastTimeTheDriverWorked]", workLogbook.LastTimeTheDriverWorked));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastBreak]", workLogbook.AccumulatedDrivingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedWorkingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedWorkingTimeSinceLastBreak]", workLogbook.AccumulatedWorkingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastDailyRest]", workLogbook.AccumulatedDrivingTimeSinceLastDailyRest));
                }
                if (workLogbook.AccumulatedTravelTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedTravelTimeSinceLastDailyRest]", workLogbook.AccumulatedTravelTimeSinceLastDailyRest));
                }
            }

            localVarRequestOptions.Operation = "RoutingApi.GetEstimatedTimeOfArrival";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EtaResponse>("/eta/{routeId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEstimatedTimeOfArrival", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        public RouteResponse GetRouteByRouteId(Guid routeId, int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> localVarResponse = GetRouteByRouteIdWithHttpInfo(routeId);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> GetRouteByRouteIdWithHttpInfo(Guid routeId, int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("routeId", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(routeId)); // path parameter

            localVarRequestOptions.Operation = "RoutingApi.GetRouteByRouteId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<RouteResponse>("/routes/{routeId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRouteByRouteId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        public async System.Threading.Tasks.Task<RouteResponse> GetRouteByRouteIdAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse> localVarResponse = await GetRouteByRouteIdWithHttpInfoAsync(routeId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns the route of a previously calculated route or an alternative route. The response will use the same parameters and contain all results of the previously calculated route. Although the route itself will be the same, other results might be slightly different such as the travel time or  toll costs. See [here](./concepts/waypoints) for more information.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<RouteResponse>> GetRouteByRouteIdWithHttpInfoAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();
			localVarRequestOptions.HeaderParameters.Add("User-Agent","ptv-generated csharp client");

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("routeId", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(routeId)); // path parameter

            localVarRequestOptions.Operation = "RoutingApi.GetRouteByRouteId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<RouteResponse>("/routes/{routeId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRouteByRouteId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
