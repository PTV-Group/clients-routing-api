/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.16
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.routing.Client;
using PTV.Developer.Clients.routing.Model;

namespace PTV.Developer.Clients.routing.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableLocationsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteReachableLocations(Guid id, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsResponse</returns>
        ReachableLocationsResponse GetReachableLocations(Guid id, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsResponse</returns>
        ApiResponse<ReachableLocationsResponse> GetReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsId</returns>
        ReachableLocationsId StartAndCreateReachableLocations(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsId</returns>
        ApiResponse<ReachableLocationsId> StartAndCreateReachableLocationsWithHttpInfo(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableLocationsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsResponse</returns>
        System.Threading.Tasks.Task<ReachableLocationsResponse> GetReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableLocationsResponse>> GetReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsId</returns>
        System.Threading.Tasks.Task<ReachableLocationsId> StartAndCreateReachableLocationsAsync(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsId)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableLocationsId>> StartAndCreateReachableLocationsWithHttpInfoAsync(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableLocationsApi : IReachableLocationsApiSync, IReachableLocationsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ReachableLocationsApi : IReachableLocationsApi
    {
        private PTV.Developer.Clients.routing.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableLocationsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableLocationsApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.routing.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.routing.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ReachableLocationsApi(PTV.Developer.Clients.routing.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.routing.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.routing.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.routing.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ReachableLocationsApi(PTV.Developer.Clients.routing.Client.ISynchronousClient client, PTV.Developer.Clients.routing.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.routing.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.routing.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.routing.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.routing.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteReachableLocations(Guid id, int operationIndex = 0)
        {
            DeleteReachableLocationsWithHttpInfo(id);
        }

        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<Object> DeleteReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableLocationsApi.DeleteReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteReachableLocationsWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<Object>> DeleteReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableLocationsApi.DeleteReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsResponse</returns>
        public ReachableLocationsResponse GetReachableLocations(Guid id, int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsResponse> localVarResponse = GetReachableLocationsWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsResponse</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsResponse> GetReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableLocationsApi.GetReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableLocationsResponse>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsResponse</returns>
        public async System.Threading.Tasks.Task<ReachableLocationsResponse> GetReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsResponse> localVarResponse = await GetReachableLocationsWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsResponse)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsResponse>> GetReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "ReachableLocationsApi.GetReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableLocationsResponse>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsId</returns>
        public ReachableLocationsId StartAndCreateReachableLocations(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsId> localVarResponse = StartAndCreateReachableLocationsWithHttpInfo(horizon, locations, waypoint, routeId, profile, horizonType, options);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsId</returns>
        public PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsId> StartAndCreateReachableLocationsWithHttpInfo(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'locations' is set
            if (locations == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'locations' when calling ReachableLocationsApi->StartAndCreateReachableLocations");
            }

            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizon", horizon));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Data = locations;

            localVarRequestOptions.Operation = "ReachableLocationsApi.StartAndCreateReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ReachableLocationsId>("/reachable-locations", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsId</returns>
        public async System.Threading.Tasks.Task<ReachableLocationsId> StartAndCreateReachableLocationsAsync(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsId> localVarResponse = await StartAndCreateReachableLocationsWithHttpInfoAsync(horizon, locations, waypoint, routeId, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.routing.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsId)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.routing.Client.ApiResponse<ReachableLocationsId>> StartAndCreateReachableLocationsWithHttpInfoAsync(int horizon, Locations locations, string? waypoint = default(string?), Guid? routeId = default(Guid?), string? profile = default(string?), HorizonType? horizonType = default(HorizonType?), ReachableOptions? options = default(ReachableOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'locations' is set
            if (locations == null)
            {
                throw new PTV.Developer.Clients.routing.Client.ApiException(400, "Missing required parameter 'locations' when calling ReachableLocationsApi->StartAndCreateReachableLocations");
            }


            PTV.Developer.Clients.routing.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.routing.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.routing.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizon", horizon));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.routing.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Data = locations;

            localVarRequestOptions.Operation = "ReachableLocationsApi.StartAndCreateReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReachableLocationsId>("/reachable-locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
