/*
 * Routing
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.16
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.ptvgroup.developer.client.routing.api;

import com.ptvgroup.developer.client.routing.ApiClient;
import com.ptvgroup.developer.client.routing.ApiException;
import com.ptvgroup.developer.client.routing.ApiResponse;
import com.ptvgroup.developer.client.routing.Pair;

import com.ptvgroup.developer.client.routing.model.Driver;
import com.ptvgroup.developer.client.routing.model.ErrorResponse;
import com.ptvgroup.developer.client.routing.model.MonetaryCostOptions;
import com.ptvgroup.developer.client.routing.model.Options;
import com.ptvgroup.developer.client.routing.model.Results;
import com.ptvgroup.developer.client.routing.model.RouteRequest;
import com.ptvgroup.developer.client.routing.model.RouteResponse;
import java.util.UUID;
import com.ptvgroup.developer.client.routing.model.Vehicle;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-02-28T07:47:51.246976Z[Etc/UTC]")
public class RoutingApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public RoutingApi() {
    this(new ApiClient());
  }

  public RoutingApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * 
   * Calculates a route by specifying a list of waypoints.
   * @param waypoints The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional
   * @param routeId Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)
   * @param profile A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to EUR_TRAILER_TRUCK)
   * @param vehicle Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)
   * @param options Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)
   * @param monetaryCostOptions Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)
   * @param results Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO 14083 from 2022 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are caclulated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO14083 from 2022 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are caclulated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2022_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional
   * @return RouteResponse
   * @throws ApiException if fails to make API call
   */
  public RouteResponse calculateRoute(List<String> waypoints, UUID routeId, String profile, Vehicle vehicle, Options options, MonetaryCostOptions monetaryCostOptions, List<Results> results) throws ApiException {
    ApiResponse<RouteResponse> localVarResponse = calculateRouteWithHttpInfo(waypoints, routeId, profile, vehicle, options, monetaryCostOptions, results);
    return localVarResponse.getData();
  }

  /**
   * 
   * Calculates a route by specifying a list of waypoints.
   * @param waypoints The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeter**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional
   * @param routeId Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information. (optional)
   * @param profile A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to EUR_TRAILER_TRUCK)
   * @param vehicle Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)
   * @param options Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)
   * @param monetaryCostOptions Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)
   * @param results Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO 14083 from 2022 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are caclulated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO14083 from 2022 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are caclulated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2022_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional
   * @return ApiResponse&lt;RouteResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RouteResponse> calculateRouteWithHttpInfo(List<String> waypoints, UUID routeId, String profile, Vehicle vehicle, Options options, MonetaryCostOptions monetaryCostOptions, List<Results> results) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = calculateRouteRequestBuilder(waypoints, routeId, profile, vehicle, options, monetaryCostOptions, results);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("calculateRoute", localVarResponse);
        }
        return new ApiResponse<RouteResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RouteResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder calculateRouteRequestBuilder(List<String> waypoints, UUID routeId, String profile, Vehicle vehicle, Options options, MonetaryCostOptions monetaryCostOptions, List<Results> results) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/routes";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "waypoints", waypoints));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("routeId", routeId));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profile", profile));
    if (vehicle != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[engineType]", vehicle.getEngineType()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[fuelType]", vehicle.getFuelType()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[electricityType]", vehicle.getElectricityType()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[averageFuelConsumption]", vehicle.getAverageFuelConsumption()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[averageElectricityConsumption]", vehicle.getAverageElectricityConsumption()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[bioFuelRatio]", vehicle.getBioFuelRatio()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[hybridRatio]", vehicle.getHybridRatio()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[dualFuelRatio]", vehicle.getDualFuelRatio()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[cylinderCapacity]", vehicle.getCylinderCapacity()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[emissionStandard]", vehicle.getEmissionStandard()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[lowEmissionZoneTypes]", vehicle.getLowEmissionZoneTypes()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[particleReductionClass]", vehicle.getParticleReductionClass()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[emptyWeight]", vehicle.getEmptyWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[loadWeight]", vehicle.getLoadWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[totalPermittedWeight]", vehicle.getTotalPermittedWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[axleWeight]", vehicle.getAxleWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[numberOfAxles]", vehicle.getNumberOfAxles()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[numberOfTires]", vehicle.getNumberOfTires()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[height]", vehicle.getHeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[heightAboveFrontAxle]", vehicle.getHeightAboveFrontAxle()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[length]", vehicle.getLength()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[width]", vehicle.getWidth()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[hazardousMaterials]", vehicle.getHazardousMaterials()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[tunnelRestrictionCode]", vehicle.getTunnelRestrictionCode()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[truckRoutes]", vehicle.getTruckRoutes()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[commercial]", vehicle.getCommercial()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[etcSubscriptions]", vehicle.getEtcSubscriptions()));
    }
    if (options != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[startTime]", options.getStartTime()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[arrivalTime]", options.getArrivalTime()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[trafficMode]", options.getTrafficMode()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[language]", options.getLanguage()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[polylineFormat]", options.getPolylineFormat()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "options[allowedCountries]", options.getAllowedCountries()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "options[prohibitedCountries]", options.getProhibitedCountries()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[currency]", options.getCurrency()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[preferTurnsOnPassengerSide]", options.getPreferTurnsOnPassengerSide()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "options[avoid]", options.getAvoid()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[blockIntersectingRoads]", options.getBlockIntersectingRoads()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[routingMode]", options.getRoutingMode()));
    }
    if (monetaryCostOptions != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[costPerKilometer]", monetaryCostOptions.getCostPerKilometer()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.getWorkingCostPerHour()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[costPerKwh]", monetaryCostOptions.getCostPerKwh()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.getCostPerFuelUnit()));
    }
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "results", results));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
   * @param routeRequest  (required)
   * @param profile A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to EUR_TRAILER_TRUCK)
   * @param vehicle Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)
   * @param driver Options regarding the driver&#39;s working hours. (optional)
   * @param options Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)
   * @param monetaryCostOptions Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)
   * @param results Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO 14083 from 2022 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are caclulated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO14083 from 2022 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are caclulated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2022_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional
   * @return RouteResponse
   * @throws ApiException if fails to make API call
   */
  public RouteResponse calculateRoutePost(RouteRequest routeRequest, String profile, Vehicle vehicle, Driver driver, Options options, MonetaryCostOptions monetaryCostOptions, List<Results> results) throws ApiException {
    ApiResponse<RouteResponse> localVarResponse = calculateRoutePostWithHttpInfo(routeRequest, profile, vehicle, driver, options, monetaryCostOptions, results);
    return localVarResponse.getData();
  }

  /**
   * 
   * Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
   * @param routeRequest  (required)
   * @param profile A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (only available for routing). (optional, default to EUR_TRAILER_TRUCK)
   * @param vehicle Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)
   * @param driver Options regarding the driver&#39;s working hours. (optional)
   * @param options Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)
   * @param monetaryCostOptions Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)
   * @param results Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO 14083 from 2022 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are caclulated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2022**) calculated according to ISO14083 from 2022 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are caclulated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2022_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional
   * @return ApiResponse&lt;RouteResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RouteResponse> calculateRoutePostWithHttpInfo(RouteRequest routeRequest, String profile, Vehicle vehicle, Driver driver, Options options, MonetaryCostOptions monetaryCostOptions, List<Results> results) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = calculateRoutePostRequestBuilder(routeRequest, profile, vehicle, driver, options, monetaryCostOptions, results);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("calculateRoutePost", localVarResponse);
        }
        return new ApiResponse<RouteResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RouteResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder calculateRoutePostRequestBuilder(RouteRequest routeRequest, String profile, Vehicle vehicle, Driver driver, Options options, MonetaryCostOptions monetaryCostOptions, List<Results> results) throws ApiException {
    // verify the required parameter 'routeRequest' is set
    if (routeRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'routeRequest' when calling calculateRoutePost");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/routes";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profile", profile));
    if (vehicle != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[engineType]", vehicle.getEngineType()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[fuelType]", vehicle.getFuelType()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[electricityType]", vehicle.getElectricityType()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[averageFuelConsumption]", vehicle.getAverageFuelConsumption()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[averageElectricityConsumption]", vehicle.getAverageElectricityConsumption()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[bioFuelRatio]", vehicle.getBioFuelRatio()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[hybridRatio]", vehicle.getHybridRatio()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[dualFuelRatio]", vehicle.getDualFuelRatio()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[cylinderCapacity]", vehicle.getCylinderCapacity()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[emissionStandard]", vehicle.getEmissionStandard()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[lowEmissionZoneTypes]", vehicle.getLowEmissionZoneTypes()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[particleReductionClass]", vehicle.getParticleReductionClass()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[emptyWeight]", vehicle.getEmptyWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[loadWeight]", vehicle.getLoadWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[totalPermittedWeight]", vehicle.getTotalPermittedWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[axleWeight]", vehicle.getAxleWeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[numberOfAxles]", vehicle.getNumberOfAxles()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[numberOfTires]", vehicle.getNumberOfTires()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[height]", vehicle.getHeight()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[heightAboveFrontAxle]", vehicle.getHeightAboveFrontAxle()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[length]", vehicle.getLength()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[width]", vehicle.getWidth()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[hazardousMaterials]", vehicle.getHazardousMaterials()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[tunnelRestrictionCode]", vehicle.getTunnelRestrictionCode()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[truckRoutes]", vehicle.getTruckRoutes()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("vehicle[commercial]", vehicle.getCommercial()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "vehicle[etcSubscriptions]", vehicle.getEtcSubscriptions()));
    }
    if (driver != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("driver[workingHoursPreset]", driver.getWorkingHoursPreset()));
    }
    if (options != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[startTime]", options.getStartTime()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[arrivalTime]", options.getArrivalTime()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[trafficMode]", options.getTrafficMode()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[language]", options.getLanguage()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[polylineFormat]", options.getPolylineFormat()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "options[allowedCountries]", options.getAllowedCountries()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "options[prohibitedCountries]", options.getProhibitedCountries()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[currency]", options.getCurrency()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[preferTurnsOnPassengerSide]", options.getPreferTurnsOnPassengerSide()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "options[avoid]", options.getAvoid()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[blockIntersectingRoads]", options.getBlockIntersectingRoads()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("options[routingMode]", options.getRoutingMode()));
    }
    if (monetaryCostOptions != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[costPerKilometer]", monetaryCostOptions.getCostPerKilometer()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.getWorkingCostPerHour()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[costPerKwh]", monetaryCostOptions.getCostPerKwh()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.getCostPerFuelUnit()));
    }
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "results", results));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(routeRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Returns a route for a previously calculated or alternative route ID.
   * @param routeId Route ID returned from a previous route calculation or alternative route. (required)
   * @return RouteResponse
   * @throws ApiException if fails to make API call
   */
  public RouteResponse getRouteByRouteId(UUID routeId) throws ApiException {
    ApiResponse<RouteResponse> localVarResponse = getRouteByRouteIdWithHttpInfo(routeId);
    return localVarResponse.getData();
  }

  /**
   * 
   * Returns a route for a previously calculated or alternative route ID.
   * @param routeId Route ID returned from a previous route calculation or alternative route. (required)
   * @return ApiResponse&lt;RouteResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RouteResponse> getRouteByRouteIdWithHttpInfo(UUID routeId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getRouteByRouteIdRequestBuilder(routeId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getRouteByRouteId", localVarResponse);
        }
        return new ApiResponse<RouteResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RouteResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getRouteByRouteIdRequestBuilder(UUID routeId) throws ApiException {
    // verify the required parameter 'routeId' is set
    if (routeId == null) {
      throw new ApiException(400, "Missing the required parameter 'routeId' when calling getRouteByRouteId");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/routes/{routeId}"
        .replace("{routeId}", ApiClient.urlEncode(routeId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
